# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project

Co-Flow is a mobile-first, audio-first web app for guided massage therapy sessions. Users explore a gesture library, run guided flows (sequences of gestures), and build custom flows. The core UX is "glanceable" — designed for hands-busy use with massive countdown typography and audio cues.

**Status:** Pre-implementation (specs and planning complete, no source code yet). Currently at Milestone 1 — repo scaffold, content pipeline, gesture library MVP, simple player MVP.

## Tech Stack

- **Build:** Vite + React + TypeScript + pnpm
- **Styling:** Tailwind CSS v4 (`@theme` + CSS variables) + shadcn/ui (Radix primitives)
- **Animation:** Framer Motion (layoutId for shared element transitions, Reorder for drag)
- **State:** Zustand (player state, user data)
- **Routing:** React Router DOM
- **Icons:** Lucide React
- **Persistence:** localStorage (favorites, resume state, custom flows)

## Commands

```bash
pnpm dev                    # Start dev server
pnpm build                  # Production build
pnpm content:new-gesture    # Scaffold new gesture JSON template
pnpm content:scan           # Generate runtime index from content JSONs
pnpm content:validate       # Validate content schemas and media files
```

Install shadcn components via CLI: `pnpm dlx shadcn@latest add <component>` — do not write them from scratch.

## Architecture

### Directory Structure
```
src/
├── app/              # App shell: layouts, providers, routing
├── features/         # Feature domains (colocated components, hooks, logic)
│   ├── gestures/     # Gesture library: list, detail, filtering
│   ├── flows/        # Flow library: presets, user flows
│   ├── builder/      # Flow builder: drag-reorder, per-step config
│   └── player/       # Guided session engine: Prev/Now/Next layout, audio chaining
├── components/ui/    # Shared atomic UI components (shadcn/ui)
├── lib/              # Hooks, Zustand stores, types, utils
├── content/          # Content source (committed to repo)
│   ├── gestures/<id>/gesture.json + media files
│   ├── flows/<id>/flow.json
│   └── generated/    # Runtime index (auto-generated by content:scan)
└── motion/           # Animation tokens (springs, durations) + motion primitives
```

### Content Pipeline

Gestures and flows are JSON files in `src/content/`, each in their own folder with co-located media (audio.mp3, video.mp4, poster.webp, captions.vtt). Audio is **required** for every gesture. The `content:scan` CLI reads all JSON files and generates `src/content/generated/index.ts` as the runtime entry point.

### Guided Player (Core Feature)

The player uses a vertical **Prev / Current / Next** card stack. Current card shows a massive countdown timer. State machine: `idle → loading → playing → paused → completed`. Audio is chained across steps with 50-150ms crossfades and cue points (Start, Halfway, 10s left, Switch Side). Resume snapshots persist to localStorage.

### Key Data Models

- **Gesture:** id (kebab-case slug), name, tags[], bodyAreas[], intensity (1-5), durationDefaults {min, default, max}, media, contraindications[], equipment[]
- **Step Flow:** id, name, steps[] where each step has gestureId, durationSec, side?, notes?, overrides?
- **Compiled Flow:** Pre-rendered single audio/video for uninterrupted playback

## Design Constraints

- **Mobile-first:** Target <450px viewport
- **Audio-first:** App must work with screen off or peripheral; use clear audio cues
- **Glanceability:** Massive typography for countdowns, minimal visual clutter
- **Offline/local-first:** No cloud sync; all data on device (PWA-ready)
- **Strict TypeScript:** No `any`; typed interfaces for all data structures
- **Feature colocation:** Feature-specific code lives in `src/features/<feature>`

## Specifications

Detailed specs live in `docs/PRD/specs/` (overview, features, content model, UX, architecture, content pipeline). Task checklists are in `docs/PRD/tasks/milestone-*.md`. The `AGENTS.md` file has architecture context and current project status. Always check these before implementing a feature.
