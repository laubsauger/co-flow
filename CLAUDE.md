# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project

Co-Flow is a mobile-first, audio-first web app for guided massage therapy sessions. Users explore a gesture library, run guided flows (sequences of gestures), and build custom flows. The core UX is "glanceable" — designed for hands-busy use with massive countdown typography and audio cues.

**Status:** Feature-complete through M1-M5. PWA-ready, deployable to GitHub Pages at `/co-flow/`. Remaining: high contrast testing (5.2.5), real device performance audit (5.4.1), actual deployment push (5.5.3), VTT captions when content exists (3.2.3-3.2.4).

## Tech Stack

- **Build:** Vite + React 19 + TypeScript + pnpm
- **Styling:** Tailwind CSS v4 (`@theme` + CSS variables, oklch colors) + shadcn/ui (Radix primitives)
- **Animation:** Framer Motion (layoutId for shared element transitions, Reorder for drag, AnimatePresence for page transitions)
- **State:** Zustand with `persist` middleware (player state, user data, user flows, session resume)
- **Routing:** React Router DOM v7 with lazy-loaded routes via React.lazy + Suspense
- **Search:** Fuse.js for weighted fuzzy search
- **Icons:** Lucide React
- **Persistence:** localStorage (favorites, resume state, custom flows)
- **PWA:** vite-plugin-pwa with Workbox service worker

## Commands

```bash
pnpm dev                    # Start dev server
pnpm build                  # Production build (tsc + vite build + PWA SW generation)
pnpm preview                # Preview production build locally
pnpm content:new-gesture    # Scaffold new gesture JSON template
pnpm content:scan           # Generate runtime index from content JSONs
pnpm content:validate       # Validate content schemas and media files
pnpm type-check             # TypeScript check without emit
pnpm lint                   # ESLint
```

Install shadcn components via CLI: `pnpm dlx shadcn@latest add <component>` — do not write them from scratch.

## Architecture

### Directory Structure
```
src/
├── app/              # App shell: layout with bottom nav, settings drawer, resume prompt
├── features/         # Feature domains (colocated components, hooks, logic)
│   ├── gestures/     # GestureList (Fuse.js search, body area filters, sort), GestureDetail
│   ├── flows/        # FlowList (tabbed curated/user), FlowDetail
│   ├── builder/      # BuilderHome, FlowEditor (Reorder.Group), GesturePicker (Sheet)
│   └── player/       # PlayerView, card stack (Prev/Current/Next), audio chainer, wake lock
├── components/       # Shared components: SafetyCheckDialog, SettingsDrawer
├── components/ui/    # shadcn/ui components (button, badge, card, input, slider, sheet, alert-dialog)
├── lib/              # Hooks, Zustand stores, types, utils
│   ├── stores/       # player.ts, user-data.ts, user-flows.ts, session-resume.ts
│   ├── hooks/        # use-reduced-motion.ts
│   └── types/        # gesture.ts, flow.ts, player.ts
├── content/          # Content source (committed to repo)
│   ├── gestures/<id>/gesture.json + media files
│   ├── flows/<id>/flow.json
│   └── generated/    # Runtime index (auto-generated by content:scan)
└── motion/           # tokens.ts (springs, durations, eases) + primitives.tsx (MotionButton, MotionCard, etc.)
```

### Content Pipeline

Gestures and flows are JSON files in `src/content/`, each in their own folder with co-located media (audio.mp3, video.mp4, poster.webp, captions.vtt). Audio is **required** for every gesture. The `content:scan` CLI reads all JSON files and generates `src/content/generated/index.ts` as the runtime entry point. Exports: `allGestures`, `allFlows`, `gestureMap`.

### Guided Player (Core Feature)

The player uses a vertical **Prev / Current / Next** card stack. Current card shows a massive countdown timer. State machine: `idle → loading → playing → paused → completed`. Audio is chained across steps with 50-150ms crossfades and cue points (Start, Halfway, 10s left, Switch Side). Resume snapshots persist to localStorage every 3s.

### Key Stores

- **usePlayerStore** — Player state machine, step navigation, timing, glance mode, wake lock
- **useUserData** — Favorites (gestures/flows), reduced motion preference. Persisted.
- **useUserFlows** — Custom flow CRUD with schema versioning. Persisted.
- **session-resume** — Periodic snapshots for session recovery (24h expiry)

### Key Data Models

- **Gesture:** id (kebab-case slug), name, tags[], bodyAreas[], intensity (1-5), durationDefaults {min, default, max}, media, contraindications[], equipment[]
- **Flow:** id, name, steps[] where each step has gestureId, durationSec, side?, notes?, overrides?
- **Compiled Flow:** Pre-rendered single audio/video for uninterrupted playback

## Design Constraints

- **Mobile-first:** Target <450px viewport
- **Audio-first:** App must work with screen off or peripheral; use clear audio cues
- **Glanceability:** Massive typography for countdowns, minimal visual clutter
- **Offline/local-first:** No cloud sync; all data on device (PWA with service worker)
- **Strict TypeScript:** No `any`; typed interfaces for all data structures
- **Feature colocation:** Feature-specific code lives in `src/features/<feature>`
- **Reduced motion:** All animations respect OS `prefers-reduced-motion` + in-app toggle via `useReducedMotion` hook. Motion primitives handle this automatically.
- **Safety:** Contraindication warnings shown before play actions, pre-session safety check dialog

## Deployment

Configured for GitHub Pages at `/co-flow/`:
- `vite.config.ts`: `base: '/co-flow/'`
- `App.tsx`: `<Router basename={import.meta.env.BASE_URL}>`
- `public/404.html`: SPA redirect handler for client-side routing
- PWA manifest scope/start_url set to `/co-flow/`

## Specifications

Detailed specs live in `docs/PRD/specs/` (overview, features, content model, UX, architecture, content pipeline). Task checklists are in `docs/PRD/tasks/milestone-*.md`. The `AGENTS.md` file has architecture context and current project status. Always check these before implementing a feature.
